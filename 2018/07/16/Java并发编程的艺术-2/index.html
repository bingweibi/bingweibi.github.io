<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="读书笔记," />










<meta name="description" content="Java内存模型 Java内存模型的基础 Java内存模型中的顺序一致性 同步原语(synchronized、volatile、final) Java内存模型的设计  Java内存模型的基础并发编程中的两个关键问题：  线程之间如何进行通信 线程之间如何同步  命令式编程中，线程之间的通信机制有两种:共享内存和消息传递">
<meta name="keywords" content="读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程的艺术(2)">
<meta property="og:url" content="http://yoursite.com/2018/07/16/Java并发编程的艺术-2/index.html">
<meta property="og:site_name" content="Wakaka">
<meta property="og:description" content="Java内存模型 Java内存模型的基础 Java内存模型中的顺序一致性 同步原语(synchronized、volatile、final) Java内存模型的设计  Java内存模型的基础并发编程中的两个关键问题：  线程之间如何进行通信 线程之间如何同步  命令式编程中，线程之间的通信机制有两种:共享内存和消息传递">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://res.infoq.com/articles/java-memory-model-1/zh/resources/22.png">
<meta property="og:image" content="https://res.infoq.com/articles/java-memory-model-3/zh/resources/1.png">
<meta property="og:image" content="https://res.infoq.com/articles/java-memory-model-3/zh/resources/2.png">
<meta property="og:image" content="https://res.infoq.com/articles/java-memory-model-3/zh/resources/3.png">
<meta property="og:image" content="https://res.infoq.com/articles/java-memory-model-3/zh/resources/5.png">
<meta property="og:image" content="https://res.infoq.com/articles/java-memory-model-4/zh/resources/3.png">
<meta property="og:image" content="https://res.infoq.com/articles/java-memory-model-4/zh/resources/4.png">
<meta property="og:image" content="https://res.infoq.com/articles/java-memory-model-4/zh/resources/5.png">
<meta property="og:image" content="https://res.infoq.com/articles/java-memory-model-4/zh/resources/6.png">
<meta property="og:image" content="https://res.infoq.com/articles/java-memory-model-5/zh/resources/33.png">
<meta property="og:updated_time" content="2018-07-16T11:14:15.646Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java并发编程的艺术(2)">
<meta name="twitter:description" content="Java内存模型 Java内存模型的基础 Java内存模型中的顺序一致性 同步原语(synchronized、volatile、final) Java内存模型的设计  Java内存模型的基础并发编程中的两个关键问题：  线程之间如何进行通信 线程之间如何同步  命令式编程中，线程之间的通信机制有两种:共享内存和消息传递">
<meta name="twitter:image" content="https://res.infoq.com/articles/java-memory-model-1/zh/resources/22.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/07/16/Java并发编程的艺术-2/"/>





  <title>Java并发编程的艺术(2) | Wakaka</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	
	<a href="https://github.com/bingweibi">
	<img style="position: absolute; top: 0; right: 0; border: 0;" 
	src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" 
	alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wakaka</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">路漫漫其修远兮，吾将上下而求索</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/16/Java并发编程的艺术-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wakaka">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wakaka">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Java并发编程的艺术(2)</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-16T19:13:18+08:00">
                2018-07-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><ul>
<li>Java内存模型的基础</li>
<li>Java内存模型中的顺序一致性</li>
<li>同步原语(synchronized、volatile、final)</li>
<li>Java内存模型的设计</li>
</ul>
<h2 id="Java内存模型的基础"><a href="#Java内存模型的基础" class="headerlink" title="Java内存模型的基础"></a>Java内存模型的基础</h2><p>并发编程中的两个关键问题：</p>
<ul>
<li>线程之间如何进行通信</li>
<li>线程之间如何同步</li>
</ul>
<p>命令式编程中，线程之间的通信机制有两种:<strong>共享内存</strong>和<strong>消息传递</strong></p>
<a id="more"></a>
<p>共享内存的并发模型中，线程之间共享程序的公共状态，通过读-写内存中的公共状态进行隐式通信。<br>消息传递的并发模型中，线程之间没有公共状态，线程之间必须通过发送消息来显示进行通信。</p>
<p>同步：程序中用于控制不同线程间操作发生相对顺序的机制。共享内存并发模型中，同步显示进行。消息传递的并发模型中，同步是隐式进行的。</p>
<p><strong>Java的并发采用的是共享内存模型。</strong></p>
<p>Java内存模型研究的是<strong>线程共享</strong>–&gt;JVM中的堆内存和方法区，而不是其他内存区域.</p>
<center><img src="https://res.infoq.com/articles/java-memory-model-1/zh/resources/22.png" alt=""></center>

<p>线程A与线程B通信步骤</p>
<ol>
<li>线程A把本地内存A中更新过的共享变量刷新到主内存中去</li>
<li>线程B到主内存中去读取线程A之前已更新过的共享变量</li>
</ol>
<p>JMM通过<strong>控制主内存与每个线程的本地内存之间的交互</strong>，来为Java程序员提供内存可见性保证。</p>
<p>重排序分为<strong>编译器重排序</strong>和<strong>处理器重排序</strong><br>处理器重排序又分为</p>
<ul>
<li>指令级并行重排序</li>
<li>内存系统重排序</li>
</ul>
<p><strong>编译器优化重排序</strong>:编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序<br><strong>指令级并行的重排序</strong>:现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序<br><strong>内存系统的重排序</strong>:由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行</p>
<p>处理器重排序时，JMM通过插入特定类型的内存屏障指令来禁止特定类型的处理器重排序。</p>
<h3 id="写缓冲区"><a href="#写缓冲区" class="headerlink" title="写缓冲区"></a>写缓冲区</h3><ol>
<li>保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟</li>
<li>通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中同一内存地址的多次写，减少对内存总线的占用。</li>
<li>每个处理器上的写缓冲区，仅仅对它所在的处理器可见，会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致。</li>
</ol>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><table>
<thead>
<tr>
<th style="text-align:left">屏障类型</th>
<th style="text-align:left">指令示例</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">LoadLoad Barriers</td>
<td style="text-align:left">Load1;LoadLoad;Load2</td>
<td style="text-align:left">确保Load1数据的装载先于Load2及所有后续装载指令的装载</td>
</tr>
<tr>
<td style="text-align:left">StoreStore Barries</td>
<td style="text-align:left">Store1;StoreStroe;Store2</td>
<td style="text-align:left">确保Store1数据对其他处理器可见(刷新到内存)先于Store2及所有后续存储指令的存储</td>
</tr>
<tr>
<td style="text-align:left">LoadStore Barries</td>
<td style="text-align:left">Load1;LoadStore;Store2</td>
<td style="text-align:left">确保Load1数据装载先于Store2及所有后续的存储指令刷新到内存</td>
</tr>
<tr>
<td style="text-align:left">StoreLoad Barries</td>
<td style="text-align:left">Store1;StroeLoad;Load2</td>
<td style="text-align:left">确保Store1数据对其他处理器变得可见(刷新到内存)先于Load2及所有后续装载指令的装载。StoreLoad Barries会使该屏障之前的所有内存访问指令完成之后，才执行屏障之后的内存访问指令</td>
</tr>
</tbody>
</table>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。</p>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
<p><strong>数据依赖性</strong>:如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。</p>
<p>数据依赖的三种情况</p>
<ol>
<li>写一个变量之后，再读这个变量<code>a=1;b=a;</code></li>
<li>写一个变量之后，再写这个变量<code>a=1;a=2;</code></li>
<li>读这个变量之后，再写这个变量<code>a=b;b=1;</code></li>
</ol>
<p>上面提到的三种情况，只要重排序两个操作的执行顺序，程序的执行结果就会发生改变</p>
<p><strong>as-if-serial</strong>：不管怎么重排序(编译器和处理器为了提高并行度),(单线程)程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p>
<p><strong>重排序对多线程的影响</strong></p>
<p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果；但是在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p>
<h2 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h2><p>数据竞争与顺序一致性</p>
<p><strong>数据竞争</strong>：在一个线程中写一个变量,在另一个线程度同一个变量,而且写和读没有通过同步来排序</p>
<p><strong>顺序一致性内存模型</strong><br>两大特性:</p>
<ol>
<li>一个线程中的所有操作必须按照程序的顺序来执行</li>
<li>(不管程序是否同步)所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li>
</ol>
<center><img src="https://res.infoq.com/articles/java-memory-model-3/zh/resources/1.png" alt="顺序一致性内存模型的视图"></center>

<p><strong>同步程序顺序一致性</strong></p>
<center><img src="https://res.infoq.com/articles/java-memory-model-3/zh/resources/2.png" alt=""></center>

<p><strong>所有操作完全按程序的顺序串行执行</strong></p>
<p><strong>未同步程序的执行特性</strong></p>
<center><img src="https://res.infoq.com/articles/java-memory-model-3/zh/resources/3.png" alt=""></center>

<p>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性:线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值(0，null,False)，JMM保证线程读操作读取到的值不会无中生有的冒出来。为实现最小安全性，JVM在堆上分配对象时，首先会对内存空间进行清零，然后才会在上面分配对象。</p>
<p>未同步程序在两个模型中的执行特性有以下三点差异</p>
<ol>
<li>程序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程的操作会按照程序的顺序执行</li>
<li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序</li>
<li>JMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保证对保证对所有的内存读/写操作都具有原子性。</li>
</ol>
<p>总线的工作机制可以把所有处理器对内存的访问以串行化的方式来执行。在任意时间点，最多只能有一个处理器可以访问内存，这个特性确保了单个总线事务之中的内存读/写操作具有原子性。</p>
<p>第3点，32位处理器上将64位的long或double拆分为两个32位来进行，这样这两个32位写操作可能就会分在不同的总线事务中执行，这样对这个64位的写操作就不具备原子性。下图为总线的工作机制</p>
<center><img src="https://res.infoq.com/articles/java-memory-model-3/zh/resources/5.png" alt=""></center>

<h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><p>volatile变量自身具有的特性</p>
<ol>
<li>可见性:对一个volatile变量的读，总是能看到(任意线程)对这个volatile变量最后的写入</li>
<li>原子性:对任意单个volatile变量的读/写具有原子性，但类似与vilatile++这种<strong>复合操作不具有原子性</strong></li>
</ol>
<p><strong>volatile写的内存语义</strong><br>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存</p>
<p><strong>volatile读的内存语义</strong><br>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量</p>
<center><img src="https://res.infoq.com/articles/java-memory-model-4/zh/resources/3.png" alt=""></center>

<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。为此,JMM采取保守策略</p>
<ol>
<li>在每个volatile写操作的前面插入一个StoreStore屏障</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障</li>
</ol>
<center><img src="https://res.infoq.com/articles/java-memory-model-4/zh/resources/4.png" alt=""></center>

<p>StoreStore屏障保障上面所有的普通写在volatile写之前刷新到主内存中。</p>
<center><img src="https://res.infoq.com/articles/java-memory-model-4/zh/resources/5.png" alt=""></center>

<center><img src="https://res.infoq.com/articles/java-memory-model-4/zh/resources/6.png" alt=""></center>


<h2 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h2><p>锁的两个功能：临界区互斥执行、锁的内存语义</p>
<p>锁释放和锁获取的内存语义</p>
<ul>
<li>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了消息</li>
<li>线程B获取一个锁，实质上是线程B接收了之前某个线程发出的消息</li>
<li>线程A释放锁，随后线程B获取这个锁，这个过程实质是线程A通过主内存向线程B发送消息</li>
</ul>
<center><img src="https://res.infoq.com/articles/java-memory-model-5/zh/resources/33.png" alt=""></center>

<p>公平锁和非公平锁的内存语义</p>
<ol>
<li>公平锁和非公平锁释放时，最后都要写一个volatile变量state</li>
<li>公平锁获取时，首先会去读volatile变量</li>
<li>非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volati读和volatile内存语义</li>
</ol>
<p>锁释放-获取的内存语义的实现至少有下面的两种方式</p>
<ol>
<li>利用volatile变量的写-读所具有的的内存语义</li>
<li>利用CAS所附带的volatile读和volatile写的内存语义</li>
</ol>
<p>Java线程之间通信的4种方式</p>
<ol>
<li>A线程写volatile变量，随后B线程读这个volatile变量</li>
<li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量</li>
<li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量</li>
<li>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量</li>
</ol>
<h2 id="final域的内存语义"><a href="#final域的内存语义" class="headerlink" title="final域的内存语义"></a>final域的内存语义</h2><p><strong>final域，编译器和处理器要遵守两个重排序规则</strong></p>
<ol>
<li>在构造函数内对一个final域的写入，与随后把这个被构成对象的引用赋值给一个引用变量，这两个操作之间不能重排序</li>
<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序</li>
</ol>
<p><strong>写final域的重排序规则</strong><br>写final域的重排序规则禁止把final域的写重排序到构造函数之外，实现包括：</p>
<ol>
<li>JMM禁止编译器把final域的写重排序到构造函数之外</li>
<li>编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造该函数之外</li>
</ol>
<p>写final域的重排序规则可以确保：在对象引用为任何线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个屏障。</p>
<p><strong>读final域的重排序规则</strong><br>读final域的重排序规则是，在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM<strong>禁止处理器</strong>重排序这两个操作，编译器会在读final域操作的前面插入一个LoadLoad屏障。</p>
<p>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。</p>
<h2 id="happens-before-1"><a href="#happens-before-1" class="headerlink" title="happens-before"></a>happens-before</h2><p>定义：</p>
<ol>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前</li>
<li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果与happens-before关系来执行的结果一直，那么这种重排序是被允许的。</li>
</ol>
<h2 id="双重检查锁定与延迟初始化"><a href="#双重检查锁定与延迟初始化" class="headerlink" title="双重检查锁定与延迟初始化"></a>双重检查锁定与延迟初始化</h2><p>双重检查锁定的来源</p>
<p>不安全的懒汉式<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class UnsafeLazyInitialization &#123;</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> Instance instance;</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Instance getInstance() &#123;</span><br><span class="line">       <span class="built_in"> if </span>(instance == null)&#123; //1：A线程执行</span><br><span class="line">           <span class="built_in"> instance </span>=<span class="built_in"> new </span>Instance();//2：B线程执行</span><br><span class="line">            &#125;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>线程A执行代码1的同时，B线程执行代码2，这个时候线程A可能会看到instance引用的对象还没有完全初始化。</p>
<p>根源在于对象初始化重排序</p>
<p>进化为安全的懒汉式<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SafeLazyInitialization &#123;</span><br><span class="line">    private static<span class="built_in"> Instance </span>instance;</span><br><span class="line"></span><br><span class="line">    public synchronized static<span class="built_in"> Instance </span>getInstance() &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">           <span class="built_in"> instance </span>= new Instance();</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>synchronized</code>带来的问题就是导致性能开销</p>
<p>进化为双重锁定<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckedLocking</span> &#123;</span>                      <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;                    <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Instance getInstance() &#123;               <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;                          <span class="comment">//4:第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckedLocking.<span class="keyword">class</span>) &#123;  <span class="comment">//5:加锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)                    <span class="comment">//6:第二次检查</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Instance();           <span class="comment">//7:问题的根源出在这里</span></span><br><span class="line">            &#125;                                            <span class="comment">//8</span></span><br><span class="line">        &#125;                                                <span class="comment">//9</span></span><br><span class="line">        <span class="keyword">return</span> instance;                                 <span class="comment">//10</span></span><br><span class="line">    &#125;                                                    <span class="comment">//11</span></span><br><span class="line">&#125;                                                        <span class="comment">//12</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>多个线程试图在同一时刻创建对象时，会通过加锁来保证只有一个线程能创建对象</li>
<li>在对象创建好之后，执行getInstance()方法将不需要获取锁，直接返回已创建好的对象</li>
</ul>
<p>缺陷：在执行到第4行的时候，代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化</p>
<p>缺陷根源所在：<br>第7行代码<code>instance = new Instance();</code>可以分解为<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();   //1：分配对象的内存空间</span><br><span class="line">ctorInstance(memory);  //2：初始化对象</span><br><span class="line">instance = memory;     //3：设置instance指向刚分配的内存地址</span><br></pre></td></tr></table></figure></p>
<p>可能发生重排序，变为<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();   //1：分配对象的内存空间</span><br><span class="line">instance = memory;     //3：设置instance指向刚分配的内存地址</span><br><span class="line">                       //注意，此时对象还没有被初始化！</span><br><span class="line">ctorInstance(memory);  //2：初始化对象</span><br></pre></td></tr></table></figure></p>
<p>这样就可能还没有完成初始化</p>
<p>解决方案</p>
<ol>
<li>不允许2，3行代码进行重排序</li>
<li>允许2,3行代码重排序，但不允许其他线程”看到”这个重排序</li>
</ol>
<p><strong>基于volatile的解决方案</strong><br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SafeDoubleCheckedLocking &#123;</span><br><span class="line">   <span class="keyword"> private</span> volatile<span class="keyword"> static</span> Instance instance;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Instance getInstance() &#123;</span><br><span class="line">       <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">            synchronized (SafeDoubleCheckedLocking.class) &#123;</span><br><span class="line">               <span class="built_in"> if </span>(instance == null)</span><br><span class="line">                   <span class="built_in"> instance </span>=<span class="built_in"> new </span>Instance();//instance为volatile，现在没问题了</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>基于类初始化的解决方案</strong><br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class InstanceFactory &#123;</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> class InstanceHolder &#123;</span><br><span class="line">       <span class="keyword"> public</span><span class="keyword"> static</span> Instance<span class="built_in"> instance </span>=<span class="built_in"> new </span>Instance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Instance getInstance() &#123;</span><br><span class="line">       <span class="built_in"> return </span>InstanceHolder.instance ;  //这里将导致InstanceHolder类被初始化</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/读书笔记/" rel="tag"># 读书笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/15/Java并发编程的艺术-1/" rel="next" title="Java并发编程的艺术(1)">
                <i class="fa fa-chevron-left"></i> Java并发编程的艺术(1)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/17/Java并发编程的艺术-3/" rel="prev" title="Java并发编程的艺术(3)">
                Java并发编程的艺术(3) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNzc1OS8xNDI5MA=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Wakaka</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">79</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/tags.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          
<br>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 
src="//music.163.com/outchain/player?type=2&id=428423168&auto=1&height=66"></iframe>

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java内存模型"><span class="nav-number">1.</span> <span class="nav-text">Java内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java内存模型的基础"><span class="nav-number">1.1.</span> <span class="nav-text">Java内存模型的基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#写缓冲区"><span class="nav-number">1.1.1.</span> <span class="nav-text">写缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存屏障"><span class="nav-number">1.1.2.</span> <span class="nav-text">内存屏障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#happens-before"><span class="nav-number">1.1.3.</span> <span class="nav-text">happens-before</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重排序"><span class="nav-number">1.1.4.</span> <span class="nav-text">重排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序一致性"><span class="nav-number">1.2.</span> <span class="nav-text">顺序一致性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile的内存语义"><span class="nav-number">1.3.</span> <span class="nav-text">volatile的内存语义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁的内存语义"><span class="nav-number">1.4.</span> <span class="nav-text">锁的内存语义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final域的内存语义"><span class="nav-number">1.5.</span> <span class="nav-text">final域的内存语义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#happens-before-1"><span class="nav-number">1.6.</span> <span class="nav-text">happens-before</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双重检查锁定与延迟初始化"><span class="nav-number">1.7.</span> <span class="nav-text">双重检查锁定与延迟初始化</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wakaka</span>

  
</div>

<div class="powered-by">
  <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
    本站访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
 

  <span class="post-meta-divider">|</span>



  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
